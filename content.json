{"pages":[],"posts":[{"title":"IDEA按块复制修改，每行都由多个空格组成一样","text":"序号：01 快捷键: Alt+shift+insert 效果图:","link":"/2020/04/07/IDEA%E4%BD%BF%E7%94%A8/01/"},{"title":"IDEA设置“运行”按钮在右上角，设置toolbar两端对齐。","text":"序号：02 有一天瞎jb设置，导致idea的run按钮跑到左边去了，如下: 我去，我的强迫症使得我没法安心工作。 经过一番搜索，找到一个同样强迫症的国际友人也在求助网友，别人给出的答案如下: 新的idea中是View -&gt; appearance:选中Navigation Bar,不选ToolBar","link":"/2020/10/23/IDEA%E4%BD%BF%E7%94%A8/02/"},{"title":"IDEA多行同时编辑","text":"序号：03 连续的行快捷键：按住Alt + 鼠标左键拖动 效果图： 不连续的行：快捷键：Alt+Shift+鼠标左键点击 效果图：","link":"/2021/04/01/IDEA%E4%BD%BF%E7%94%A8/03/"},{"title":"U盘安装centos 7 提示“&#x2F;dev&#x2F;root does not exist”的解决办法","text":"序号：01 家里有台旧笔记本，就想着装个linux玩玩，做好U盘镜像，安装时报错： 1Warning: /dev/root does not exist, could not boot &emsp;&emsp;找了网上很多解决办法，都是cd /dev，查看U盘设备，然后重启按Tab或者e进入配置编辑界面修改，但是的我的显示设备有好多个sdb之类的，蒙了，然后有看到一篇文章https://blog.csdn.net/qq_25868251/article/details/83900307说修改文件的，我把两者结合了一下，就是在启动时按Tab或e显示vmlinuz的配置信息如下： 1initrd=initrd.imginst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 rd.live.check quiet 修改为： 1initrd=initrd.imginst.stage2=hd:LABEL=CentOS\\x207\\x20x8 rd.live.check quiet","link":"/2020/04/04/Linux/01/"},{"title":"记一次Mybatis-Plus使用碰到的问题“Error attempting to get columjn ‘xxxx‘”","text":"序号：01 &emsp;&emsp;在项目中使用到了lombok插件，错误的以为@Data注解会自动生产无参构造函数，导致了一个问题。 “Error attempting to get columjn ‘xxxx‘” &emsp;&emsp;在实体类中自己写了一个个别参数的带参构造函数。 &emsp;&emsp;mybatis-plus在查询到结果后，将数据转为实体的时候，如果没有无参构造函数即defaultconstructor，就会使用已定义的构造函数来匹配结果数据第几列转为javaBean的哪个属性。 &emsp;&emsp;这个过程中，如果该构造函数不为包含全部属性的构造函数，就会造成数据在转化时对应的列不对，例如将String类型的数据，对应到Date类型的属性上，这是就会出现Error attempting to get columjn ‘xxxx’的错误。 所以如果使用Lombok,记得加上@NoArgsConstrutor注解，生成无参构造函数。","link":"/2021/05/31/Mybatis-Plus/01/"},{"title":"Mybatis-Plus自定义TypeHandler的使用","text":"序号：02 &emsp;&emsp;Mybatis-Plus可通过自定义的TypeHandler实现某个属性在插入数据库以及查询时的自动转换，本例中是要将Map类型的属性转化成CLOB，然后存入数据库。由于是复杂的Map，mp自带的json转换器会丢失部分信息。 类型转换器可以通过注解配置 java 类型和 jdbc 类型： @MappedTypes：注解配置 java 类型 @MappedJdbcTypes：注解配置 jdbc 类型 定义： 1234567891011121314151617181920212223242526272829303132333435@Slf4j@MappedTypes({Object.class})@MappedJdbcTypes(JdbcType.VARCHAR)public class WeightListTypeHandler extends AbstractJsonTypeHandler&lt;Object&gt; { private static Gson gson = new Gson(); private final Class&lt;?&gt; type; public WeightListTypeHandler(Class&lt;?&gt; type) { if (log.isTraceEnabled()) { log.trace(&quot;WeightListTypeHandler(&quot; + type + &quot;)&quot;); } Assert.notNull(type, &quot;Type argument cannot be null&quot;); this.type = type; } @Override protected Object parse(String json) { Type type1 = new TypeToken&lt;Map&lt;String, List&lt;WeightItem&gt;&gt;&gt;(){}.getType(); return gson.fromJson(json, type1); } @Override protected String toJson(Object obj) { return gson.toJson(obj); } public static void setGson(Gson gson) { Assert.notNull(gson, &quot;Gson should not be null&quot;); WeightListTypeHandler.gson = gson; }} 使用：&emsp;&emsp;注意@TableName 注解 autoResultMap 属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Data@NoArgsConstructor@TableName(value = &quot;mix_target&quot;,autoResultMap = true)public class MixTarget extends Model&lt;MixTarget&gt; { @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; /** *指标描述 */ @TableField(&quot;description&quot;) private String description; /** * 指标名 */ @TableField(&quot;name&quot;) private String name; /** * 对应属性名 */ @TableField(&quot;property_name&quot;) private String propertyName; /** * 起始点类型 */ @TableField(&quot;source_type&quot;) private String sourceType; /** * 属性对应权值列表 * key 属性名 value指定条件下的权值 */ @TableField(value = &quot;weight_list&quot;,typeHandler = WeightListTypeHandler.class,jdbcType = JdbcType.CLOB) private Map&lt;String, List&lt;WeightItem&gt;&gt; weightList; /** * 运行状态 * 0 新建未运行 * 1 运行中 * 2 已运行 成功 * 3 已运行 失败 */ @TableField(&quot;status&quot;) private Integer status; /** * 是否可用 * 1 true * 0 false */ @TableField(&quot;enable&quot;) private Integer enable; @TableField(&quot;create_time&quot;) private LocalDateTime createTime;}","link":"/2021/05/31/Mybatis-Plus/02/"},{"title":"yyyy-MM-dd hh:mm:ss 各个字母含义-SimpleDateFormat","text":"序号：01 yyyy : 代表年(不去区分大小写) 假设年份为 2017 “y” , “yyy” , “yyyy” 匹配的都是4位完整的年 如 : “2017” “yy” 匹配的是年分的后两位 如 : “15” 超过4位,会在年份前面加”0”补位 如 “YYYYY”对应”02017” MM : 代表月(只能使用大写) 假设月份为 9 “M” 对应 “9” “MM” 对应 “09” “MMM” 对应 “Sep” “MMMM” 对应 “Sep” 超出3位,仍然对应 “September” dd : 代表日(只能使用小写) 假设为13号 “d” , “dd” 都对应 “13” 超出2位,会在数字前面加”0”补位. 例如 “dddd” 对应 “0013” hh : 代表时(区分大小写,大写为24进制计时,小写为12进制计时) 假设为15时 “H” , “HH” 都对应 “15” , 超出2位,会在数字前面加”0”补位. 例如 “HHHH” 对应 “0015” “h” 对应 “3” “hh” 对应 “03” , 超出2位,会在数字前面加”0”补位. 例如 “hhhh” 对应 “0003” mm : 代表分(只能使用小写) 假设为32分 “m” , “mm” 都对应 “32” , 超出2位,会在数字前面加”0”补位. 例如 “mmmm” 对应 “0032” ss : 代表秒(只能使用小写) 假设为15秒 “s” , “ss” 都对应 “15” , 超出2位,会在数字前面加”0”补位. 例如 “ssss” 对应 “0015” E : 代表星期(只能使用大写) 假设为 Sunday “E” , “EE” , “EEE” 都对应 “Sun” “EEEE” 对应 “Sunday” , 超出4位 , 仍然对应 “Sunday” a : 代表上午还是下午,如果是上午就对应 “AM” , 如果是下午就对应 “PM”","link":"/2021/01/13/Java/01/"},{"title":"记录一次HashSet的iterator.remove()方法不生效，不能删除元素的原因。","text":"序号：02 首先说明业务场景：&emsp;&emsp;对公司数据的driver增加离线节点上线重连的功能。 大致功能需求，在线连接中有 节点1、节点2、节点3······，这时节点2离线了，将节点2移除在线连接池，加入离线节点池，然后定时访问离线节点池，尝试重新连接。由于driver连接自身没有保存连接的uri信息，所以我对driver连接自己封装了一层，大致如下： 原driver连接新建方式： 1Driver driver = XXX.driver(uri, db, username, password); 封装的Driver： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xxx.xxx.xxx; import lombok.Data;import lombok.extern.slf4j.Slf4j; /** * &lt;p&gt; 对xxx封装一层，增加uri属性 &lt;p&gt; * * @author: chen * @create: 2021-04-27 **/@Slf4j@Datapublic class DriverAgent { /** * bolt地址 */ private String uri; private Driver driver; private String db; private String username; private String password; public DriverAgent () { } public DriverAgent (String uri, String db, String username, String password) { this.uri = uri; this.db= db; this.username = username; this.password = password; this.driver= xxx.driver(uri, db, username, password); } public Boolean reconnect(){ try { this.driver = xxx.driver(uri, db, username, password); log.info(uri + &quot; has reconnected&quot;); }catch (Exception e){ log.error(&quot;reconnection Failed：&quot; + e.getMessage()); return false; } return true; } } 坑就出现在这里，首先这里我使用了lombok的@Data注解，它会生成以下方法: 所有属性的get和set方法 toString 方法 hashCode方法 equals方法 注意，重写了hashCode方法和equals方法。 &emsp;&emsp;出现的问题：使用HashSet作为离线节点存储的容器，重连时使用迭代器遍历HashSet，调用reconnect方法，返回成功后调用iterator.remove()将当前节点从离线节点池中移除。但是测试过程中发现离线的节点重连成功后，iterator.remove()并未将其从HashSet中移除。 1234567891011121314151617singleThreadExecutor.execute(() -&gt; { while (true){ Iterator&lt;DriverAgent&gt; iterator = offlineNodes.iterator(); while (iterator.hasNext()){ DriverAgent agent = iterator.next(); if(agent.reconnect()){ agentList.add(agent); iterator.remove(); } } try { TimeUnit.SECONDS.sleep(60); } catch (InterruptedException e) { e.printStackTrace(); } }}); &emsp;&emsp;经过阅读源码发现，HashSet实现借助的是HashMap，HashSet的Iterator获取的是HashMap.keySet().Iterator()。其返回的是一个EntryIterator，而EntryIterator继承自HashIterator，HashIterator的remove()方法是通过调用HashMap的removeNode方法实现的。 1234567891011public final void remove() { Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount;} removeNode()方法源码 1234567891011121314151617181920212223242526272829303132333435363738394041final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; //重点看下面这个if if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null;} &emsp;&emsp;可以看到，方法中会通过调用hashCode方法和equals方法去判断当前元素是不是要被删除的元素，而在前面，这两个方法是被重写过的，重写过程中，两个方法的返回值会与各个属性值挂钩，所以这里在我调用了reconnect方法后，如果通过hashCode和equals来比较两个类，其实已经不是同一个类了，因此导致iterator.remove()找不到要删除的元素。","link":"/2021/04/29/Java/02/"},{"title":"Spring Boot 2.x版本，启动报错“Error creating bean with name &#39;dataSource&#39; defined in class path resource”","text":"序号：01 在使用spingBoot 2.x版本的时候，使用alibaba的druid数据库连接池，com.github.pagehelper的分页插件1.1.2版本，启动项目报错。 错误日志如下： 1234Error creating bean with name 'dataSource' defined in class path resource [com/alibaba/druid/spring/boot/autoconfigure/DruidDataSourceAutoConfigure.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.sql.DataSource]: Factory method 'dataSource' threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/boot/bind/RelaxedDataBinder 解决方案一：使用jdbc连接 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 解决方案二：boot版本改为1.5.x版本 解决方案三： 第一步：把druid连接池版本更新到最新1.1.13 第二步：分页插件更新到1.2.3 123456789101112&lt;!-- 分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alibaba的druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt;&lt;/dependency&gt; 第三步：使用com.mysql.cj.jdbc.Driver（application.yml文件） 123456789datasource: name: test url: jdbc:mysql://127.0.0.1:3306/hometeach?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver #就是修改了这一行","link":"/2021/04/08/Spring%20Boot/01/"},{"title":"SpringBoot 2.0 实现自定义接口参数解析器","text":"序号：02 对于前端作为参数传过来的json数据，Spring是如何转换为Java Bean的， 又如何自定义这一过程呢？ Spring将参数中的json转为Java Bean主要依赖于@RequestBody注解，该注解的作用原理，请看：https://www.jianshu.com/p/c1b8315c5a03 下面讲如何实现自定义这一过程: 1、首先，自定义一个注解，使用该注解标记的参数则使用自定义的参数解析器 MyRequestBody.java 12345678910111213141516package com.example.springboottest.annotation; import java.lang.annotation.*; /** * &lt;p&gt; 自定义参数解析注解 &lt;p&gt; * * @author: chen * @create: 2021-04-08 **/@Documented@Target({ElementType.PARAMETER, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface MyRequestBody { } 2、实现自定义参数解析器 CustomJsonMethodArgumentResolver.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.springboottest.config; import com.example.springboottest.annotation.MyRequestBody;import com.google.gson.Gson;import org.apache.commons.io.IOUtils;import org.springframework.core.MethodParameter;import org.springframework.util.StringUtils;import org.springframework.web.bind.support.WebDataBinderFactory;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.ModelAndViewContainer; import javax.servlet.http.HttpServletRequest;import java.io.InputStream;import java.nio.charset.Charset; /** * &lt;p&gt; &lt;p&gt; * * @author: chen * @create: 2021-04-08 **/public class CustomJsonMethodArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(MethodParameter parameter) { //被自定义注解标记的参数使用该解析器 if(parameter.hasParameterAnnotation(MyRequestBody.class)){ return true; } return false; } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { String body = getRequestBody(webRequest); if(StringUtils.isEmpty(body)){ return null; } System.out.println(body); //TODO 可以在这里实现一些自定操作，例如自定json的解析过程 return new Gson().fromJson(body,parameter.getParameterType()); } private String getRequestBody(NativeWebRequest webRequest) { HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); try { return IOUtils.toString(servletRequest.getInputStream(), Charset.forName(&quot;utf-8&quot;)); }catch (Exception e){ e.printStackTrace(); } return &quot;&quot;; }} 3、注入自定义解析器 CustomWebMvcConfigurer.java 12345678910111213141516171819202122package com.example.springboottest.config; import org.springframework.context.annotation.Configuration;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.List; /** * &lt;p&gt; &lt;p&gt; * * @author: chen * @create: 2021-04-08 **/@Configurationpublic class CustomWebMvcConfigurer implements WebMvcConfigurer { @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) { resolvers.add(new CustomJsonMethodArgumentResolver()); }} 4、测试接口 1234567891011121314151617181920212223package com.example.springboottest.controller; import com.example.springboottest.annotation.MyRequestBody;import com.example.springboottest.entity.Person;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*; /** * &lt;p&gt; &lt;p&gt; * * @author: chen * @create: 2021-04-08 **/@ResponseBody@Controller@RequestMapping(&quot;/test&quot;)public class TestController { @PostMapping(value = &quot;/post&quot;) public String testApi(@MyRequestBody Person person){ return person.getName(); }} 5、效果图","link":"/2020/04/07/Spring%20Boot/02/"},{"title":"Neo4j+SpringBoot实现节点以及关系的增删改查（Spring Data Neo4j）","text":"序号：04 &emsp;&emsp;公司让学习一下Neo4j在SpringBoot框架下的使用，我知道有个Spring DATA Neo4J，在网上找了很多教程，有些地方让我困惑了很久，所以记下来希望能给后面学习的伙伴一些帮助。 先上效果图： 一、开发环境IDE：idea JDK：1.8 先搭建一个普通的SpringBoot项目，然后导入依赖。 pom.xml如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;neo4jdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;neo4jdemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Neo4j相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.neo4j&lt;/groupId&gt; &lt;artifactId&gt;neo4j-ogm-core&lt;/artifactId&gt; &lt;version&gt;3.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-neo4j&lt;/artifactId&gt; &lt;version&gt;5.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Json处理 @JsonIdentityInfo(generator= JSOGGenerator.class)用到--&gt; &lt;dependency&gt; &lt;groupId&gt;com.voodoodyne.jackson.jsog&lt;/groupId&gt; &lt;artifactId&gt;jackson-jsog&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; yml配置： 123456spring: data: neo4j: uri: bolt://localhost:7687 username: neo4j password: cldev 二、代码部分目录结构： &emsp;&emsp;为了简单，本项目节点只设置一种类型（User），实现的关系的某一个User知道另一User，关系（Know）。 首先编写User节点类（UserNode .java）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.example.neo4jdemo.entity.node;import com.fasterxml.jackson.annotation.JsonIdentityInfo;import com.voodoodyne.jackson.jsog.JSOGGenerator;import org.neo4j.ogm.annotation.*;import java.util.HashSet;import java.util.Set;@JsonIdentityInfo(generator= JSOGGenerator.class)@NodeEntity(label = &quot;User&quot;)public class UserNode { @Id @GeneratedValue private Long nodeId; @Property(name = &quot;name&quot;) private String name; @Property(name = &quot;age&quot;) private int age; @Property(name = &quot;sex&quot;) private String sex; /* 注意这个地方：并不是说加了这个注解，然后下面实现了addKnows这个方法在以后调用addKnows * 就可以实现关系的增加，这是不对的，我看了很多教程没有说明。这个addKnows方法，只有在节点未被 * 添加之前，调用该方法添加关系，然后再调用UserService中的create方法，这样关系才会同时被添加到图 * 数据库中。如果想实现两个已有节点之间增加关系，需要单独实现 */ @Relationship(type = &quot;know&quot; ,direction = Relationship.OUTGOING) private Set&lt;UserNode&gt; knows = new HashSet&lt;&gt;(); public Long getNodeId() { return nodeId; } public void setNodeId(Long nodeId) { this.nodeId = nodeId; } public String getName() { return name; } public void setName(String name) { this.name = name } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public Set&lt;UserNode&gt; getKnows() { return knows; } public void setKnows(Set&lt;UserNode&gt; knows) { this.knows = knows; } public Boolean addKnows(UserNode to){ return this.knows.add(to); } @Override public String toString() { return &quot;UserNode{&quot; + &quot;nodeId=&quot; + nodeId + &quot;, name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, sex='&quot; + sex + '\\'' + '}'; } public UserNode() {}} 关系类（Know.java） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.neo4jdemo.entity.relationship;import com.example.neo4jdemo.entity.node.UserNode;import com.fasterxml.jackson.annotation.JsonIdentityInfo;import com.voodoodyne.jackson.jsog.JSOGGenerator;import org.neo4j.ogm.annotation.*;/** * @program: neo4jdemo * @description: 知道关系类 * @author: chen * @create: 2020-07-27 **/@JsonIdentityInfo(generator= JSOGGenerator.class)@RelationshipEntity(type = &quot;know&quot;)public class Know { @Id @GeneratedValue private Long id; @StartNode private UserNode from; @EndNode private UserNode to; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public UserNode getFrom() { return from; } public void setFrom(UserNode from) { this.from = from; } public UserNode getTo() { return to; } public void setTo(UserNode to) { this.to = to; } public Know() { } public Know(UserNode from, UserNode to) { this.from = from; this.to = to; } @Override public String toString() { return &quot;Know{&quot; + &quot;id=&quot; + id + &quot;, from=&quot; + from + &quot;, to=&quot; + to + '}'; }} KnowRepository.java 12345678910111213141516171819package com.example.neo4jdemo.repository;import com.example.neo4jdemo.entity.relationship.Know;import org.springframework.data.neo4j.annotation.Query;import org.springframework.data.neo4j.repository.Neo4jRepository;import org.springframework.data.repository.query.Param;/** * @program: neo4jdemo * @description: 知道关系接口类 * @author: chen * @create: 2020-07-27 **/public interface KnowRepository extends Neo4jRepository&lt;Know,Long&gt; { @Query(&quot;MATCH (fromNode) WHERE id(fromNode) = {fromId} MATCH (toNode) WHERE id(toNode) = {toId} MATCH (fromNode)-[r]-&gt;(toNode) DELETE r&quot;) void deleteByNodeId(@Param(value = &quot;fromId&quot;) long fromId,@Param(value = &quot;toId&quot;) long toId);} UserRepository.java 基础的增删改查Spring Data Neo4j已经封装好在Neo4jRepository里面了。 123456789101112131415161718192021package com.example.neo4jdemo.repository;import com.example.neo4jdemo.entity.node.UserNode;import org.springframework.data.neo4j.annotation.Query;import org.springframework.data.neo4j.repository.Neo4jRepository;importorg.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;@Repositorypublic interface UserRepository extends Neo4jRepository&lt;UserNode,Long&gt; {// @Query(&quot;MATCH (n:User) RETURN n &quot;)// List&lt;UserNode&gt; getUserNodeList();// @Query(&quot;create (n:User{name:{name},age:{age},sex:{sex}}) RETURN n &quot;)// UserNode addUserNode(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;)int age, @Param(&quot;sex&quot;) String sex); @Query(&quot;MATCH (n) WHERE id(n) = :#{#userNode.nodeId} SET n.name = :#{#userNode.name},n.age = :#{#userNode.age},n.sex = :#{#userNode.sex} RETURN n&quot;) UserNode updateByNode(@Param(&quot;userNode&quot;) UserNode userNode); } UserService.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.neo4jdemo.service;import com.example.neo4jdemo.entity.node.UserNode;import com.example.neo4jdemo.entity.relationship.Know;import java.util.List;import java.util.Optional;public interface UserService { /** * @Description: 添加user节点 * @Params: [UserNode] * @return: int * @Author: chen * @Date: 2020/7/27 */ UserNode create(UserNode userNode); /** * @Description: 删除 * @Author: chen * @Date: 2020/7/27 */ void deleteById(Long id); /** * @Description: 查询 * @Author: chen * @Date: 2020/7/27 * @return */ Optional&lt;UserNode&gt; findById(long id); /** * @Description: 获取所有User节点 * @Params: null * @return: List * @Author: chen * @Date: 2020/7/27 */ List&lt;UserNode&gt; findAll(); /** * @Description: 增加“知道”关系 * @Author: chen * @Date: 2020/7/27 */ Know addIKnows(UserNode fromNode, UserNode toNode); UserNode updateByNode(UserNode userNode); void deleteKnowByNodeId(long fromId,long toId);} UserServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.neo4jdemo.service.impl;import com.example.neo4jdemo.entity.node.UserNode;import com.example.neo4jdemo.entity.relationship.Know;import com.example.neo4jdemo.repository.KnowRepository;import com.example.neo4jdemo.repository.UserRepository;import com.example.neo4jdemo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;@Servicepublic class UserServiceImpl implements UserService { @Autowire private UserRepository userRepository; @Autowire private KnowRepository knowRepository; @Override public UserNode create(UserNode userNode) { return userRepository.save(userNode); } @Override public void deleteById(Long id) { userRepository.deleteById(id); } @Override public Optional&lt;UserNode&gt; findById(long id) { return userRepository.findById(id); } @Override public List&lt;UserNode&gt; findAll() { return (List&lt;UserNode&gt;) userRepository.findAll(); } @Override public Know addIKnows(UserNode fromNode, UserNode toNode) { Know newKnow = new Know(fromNode,toNode); return knowRepository.save(newKnow); } @Override public UserNode updateByNode(UserNode userNode) { return userRepository.updateByNode(userNode); } @Override public void deleteKnowByNodeId(long fromId, long toId) { knowRepository.deleteByNodeId(fromId,toId); }} UserController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.example.neo4jdemo.controller;import com.example.neo4jdemo.entity.node.UserNode;import com.example.neo4jdemo.entity.relationship.Know;import com.example.neo4jdemo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;import java.util.Optional;/*** @program: neo4jdemo* @description: 控制层* @author: chen* @create: 2020-07-27**/@RestControllepublic class UserController { @Autowired private UserService userService; /** * @Description: 添加节点 * @Author: chen * @Date: 2020/7/27 */ @RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST) public UserNode addUserNode(@RequestBody UserNode userNode) { return userService.create(userNode); } /** * @Description: 根据id删除 * @Author: chen * @Date: 2020/7/27 */ @RequestMapping(path = &quot;/delete&quot;, method = RequestMethod.POST) public int delUserNodeById(@RequestParam(value = &quot;id&quot;) long id) { userService.deleteById(id); System.out.println(id); return 1; } /** * @Description: 根据id更新 * @Author: chen * @Date: 2020/7/27 */ @RequestMapping(path = &quot;/update&quot;, method = RequestMethod.POST) public UserNode updateUserNodeByNode(@RequestBody UserNode userNode) return userService.updateByNode(userNode) } @RequestMapping(path = &quot;/get&quot;, method = RequestMethod.GET) public UserNode getUserNodeById(@RequestParam(value = &quot;id&quot;) long id) { Optional&lt;UserNode&gt; optionalUserNode = userService.findById(id); if(optionalUserNode.isPresent()){ return optionalUserNode.get(); }else{ return null; } } /** * @Description: 查找所有节点 * @Author: chen * @Date: 2020/7/27 */ @RequestMapping(path = &quot;/list&quot;, method = RequestMethod.GET) public List&lt;UserNode&gt; getUserNodeList() { return userService.findAll(); } @RequestMapping(path = &quot;/addKnows&quot;, method = RequestMethod.POST) public Know addKnowsById(@RequestParam(value = &quot;from&quot;) long fromId, @RequestParam(value = &quot;to&quot;) long toId) { Optional&lt;UserNode&gt; fromOpt = userService.findById(fromId); Optional&lt;UserNode&gt; toOpt = userService.findById(toId); if(fromOpt.isPresent()&amp;&amp;toOpt.isPresent()){ return userService.addIKnows(fromOpt.get(),toOpt.get()); }else{ return null; } } @RequestMapping(path = &quot;/delKnows&quot;, method = RequestMethod.POST) public String deleteKnowsByNodeId(@RequestParam(value = &quot;from&quot;) long fromId, @RequestParam(value = &quot;to&quot;) long toId) { Optional&lt;UserNode&gt; fromOpt = userService.findById(fromId); Optional&lt;UserNode&gt; toOpt = userService.findById(toId); if(fromOpt.isPresent()&amp;&amp;toOpt.isPresent()){ userService.deleteKnowByNodeId(fromId,toId); return &quot;ok&quot;; }else{ return &quot;false&quot;; } }} Neo4jConfig.java 我也不知道干啥的 1234567891011package com.example.neo4jdemo.config;import org.springframework.context.annotation.Configuration;import org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;@Configuration@EnableNeo4jRepositories(basePackages = &quot;com.example.neo4jdemo.repository&quot;)@EnableTransactionManagement // 激活SDN隐式事务public class Neo4jConfig {} 重点就是User中的那段注释，是我困扰了很久的问题，希望大家能够避坑。有什么问题可以留言。","link":"/2020/07/28/Spring%20Boot/04/"},{"title":"Hive SQL--使用hive计算中位数以及分位数","text":"序号：01 &emsp;&emsp;开门见山的说，hive中有两个函数percentile和percentile_approx，可以用来计算分位数。 而中位数即2分位数，那么同样可以使用该函数计算。具体使用方如下： percentile：percentile(col, p) col是要计算的列（值必须为int类型），p的取值为0-1，若为0.5，那么就是2分位数，即中位数。 percentile_approx：percentile_approx(col, p)。列为数值类型都可以。 percentile_approx还有一种形式percentile_approx(col, p，B)，参数B控制内存消耗的近似精度，B越大，结果的精度越高。默认值为10000。当col字段中的distinct值的个数小于B时，结果就为准确的百分位数。 其他使用方法请参考其他文档，这里不赘述。 写这篇文章的主要目的是我看了很多篇文章都是复制粘贴的，没有自己实践，其中参数p应为0.5时，计算所得才是中位数，但是很多文章写得都是0.2。 测试部分 1、先建测试表 1234567CREATE TABLE temp_median_test (id int,number bigint)ROW FORMAT DELIMITED fields terminated by '\\t'STORED AS ORC 2、插入数据 1234567INSERT INTO temp_median_test VALUES(1,1);INSERT INTO temp_median_test VALUES(2,2);INSERT INTO temp_median_test VALUES(3,3);INSERT INTO temp_median_test VALUES(4,4);INSERT INTO temp_median_test VALUES(5,5);INSERT INTO temp_median_test VALUES(6,6);INSERT INTO temp_median_test VALUES(7,7); 3、执行查询 1SELECT percentile(number,0.5) from temp_median_test; 4、查询结果","link":"/2020/10/14/%E5%A4%A7%E6%95%B0%E6%8D%AE/01/"},{"title":"SpringBoot+Shiro+Jwt实现根据链接中参数进行权限控制","text":"序号：03 业务需求&emsp;&emsp;实现一个论坛系统，根据用户组，来区分用户可访问的模块，用户访问无权限访问的文章时，给出相应提示。 实现思路&emsp;&emsp;Shiro是通过在AuthorizingRealm中获取当前用户权限（这里为可访问文章类型id），保存在SimpleAuthorizationInfo中，然后通过subject.isPermitted(文章类型id)来判断是否有权限访问;&emsp;&emsp;所以可以在doGetAuthorizationInfo中根据token获取到用户信息，从数据库中联合查询到可以访问的文章类型id，添加到用户权限中，isAccessAllowed中获取用户访问链接中的参数，调用 subject.isPermitted(id)，判断是否拥有该权限。 注意点： &emsp;&emsp;subject.isPermitted(id)调用前一定要先调用subject.login（token）；方法，不然在isPermitted时不会进行授权 重点代码自定义过滤器，重写isAccessAllowed方法。 123456789101112131415161718192021public class JWTFilter extends AuthorizationFilter { ... @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { logger.info(&quot;-----isAccessAllowed----&quot;); if (isLoginAttempt(request, response)) { try { executeLogin(request, response); } catch (Exception e) { response401(response); } } String id = request.getParameter(&quot;id&quot;); Subject subject = getSubject(request,response); boolean flag = subject.isPermitted(id); return flag; } ...} 自定义realm，重写doGetAuthorizationInfo方法。 授权代码: 1234567891011121314151617181920212223242526272829303132333435363738394041public class CustomRealm extends AuthorizingRealm{ ... /** * 获取权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { logger.info(&quot;开始鉴权------------doGetAuthorizationInfo&quot;); User user = (User) principalCollection.getPrimaryPrincipal(); List&lt;String&gt; userRoles = new ArrayList&lt;String&gt;(); Set&lt;String&gt; categoryIds = new HashSet&lt;&gt;(); QueryWrapper queryUserWrapper = new QueryWrapper(); queryUserWrapper.eq(&quot;uuid&quot;,user.getUuid()); user = userService.getOne(queryUserWrapper); if(null != user){ Ugroup ugroup = ugroupService.getById(user.getGroupId()); userRoles.add(ugroup.getName()); QueryWrapper queryWrapper = new QueryWrapper(); queryWrapper.eq(&quot;idx_group_id&quot;,ugroup.getId()); List&lt;GroupCategory&gt; groupCategories = groupCategoryService.list(queryWrapper); if (groupCategories.size() &gt; 0){ for (GroupCategory groupCategory : groupCategories){ categoryIds.add(groupCategory.getCategoryId().toString()); } } }else{ throw new AuthorizationException(); } //为当前用户设置角色和权限 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRoles(userRoles); authorizationInfo.addStringPermissions(categoryIds); return authorizationInfo; } ...} 全部代码pom.xml 123456789101112131415161718&lt;!--aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; CustomRealm.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.zyc.shiro; import com.baomidou.mybatisplus.core.conditions.Wrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.zyc.constant.CommonConstant;import com.zyc.dao.GroupCategoryMapper;import com.zyc.dao.UgroupMapper;import com.zyc.entity.GroupCategory;import com.zyc.entity.Ugroup;import com.zyc.entity.User;import com.zyc.redis.JwtRedisDAO;import com.zyc.service.GroupCategoryService;import com.zyc.service.UgroupService;import com.zyc.service.UserService;import com.zyc.util.JWTUtils;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authz.AuthorizationException;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired; import java.util.*; /** * 鉴权 */public class CustomRealm extends AuthorizingRealm { static Logger logger = LoggerFactory.getLogger(CustomRealm.class); @Autowired private UgroupService ugroupService; @Autowired private GroupCategoryService groupCategoryService; @Autowired private UserService userService; @Autowired private JwtRedisDAO jwtRedisDAO; /** * 必须重写此方法，不然Shiro会报错 */ @Override public boolean supports(AuthenticationToken token) { return token instanceof JWTToken; } /** * 获取权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { logger.info(&quot;开始鉴权------------doGetAuthorizationInfo&quot;); User user = (User) principalCollection.getPrimaryPrincipal(); List&lt;String&gt; userRoles = new ArrayList&lt;String&gt;(); Set&lt;String&gt; categoryIds = new HashSet&lt;&gt;(); QueryWrapper queryUserWrapper = new QueryWrapper(); queryUserWrapper.eq(&quot;uuid&quot;,user.getUuid()); user = userService.getOne(queryUserWrapper); if(null != user){ Ugroup ugroup = ugroupService.getById(user.getGroupId()); userRoles.add(ugroup.getName()); QueryWrapper queryWrapper = new QueryWrapper(); queryWrapper.eq(&quot;idx_group_id&quot;,ugroup.getId()); List&lt;GroupCategory&gt; groupCategories = groupCategoryService.list(queryWrapper); if (groupCategories.size() &gt; 0){ for (GroupCategory groupCategory : groupCategories){ categoryIds.add(groupCategory.getCategoryId().toString()); } } }else{ throw new AuthorizationException(); } //为当前用户设置角色和权限 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRoles(userRoles); authorizationInfo.addStringPermissions(categoryIds); return authorizationInfo; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) { logger.info(&quot;CustomRealm------------------doGetAuthenticationInfo&quot;); Map claims = JWTUtils.getClaims(CommonConstant.JWT_SECRET, (String) authenticationToken.getPrincipal()); if (claims == null) { //没找到帐号 throw new UnknownAccountException(); } String uuid = (String) claims.get(&quot;uuid&quot;); QueryWrapper queryWrapper = new QueryWrapper(); queryWrapper.eq(&quot;uuid&quot;,uuid); User user = userService.getOne(queryWrapper); //logger.info(user.toString()); if(null == user){ throw new UnknownAccountException(); } String token = jwtRedisDAO.get(CommonConstant.ADMIN_JWT_PREFIX + uuid); //logger.info(&quot;token {}&quot;, authenticationToken.getPrincipal()); if (token == null || !token.equals(authenticationToken.getPrincipal())) { throw new AuthorizationException(); } //交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，可以自定义实现 return new SimpleAuthenticationInfo( //用户信息 user, authenticationToken.getPrincipal(), //realm name getName() ); }} JWTFilter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package com.zyc.shiro; import com.alibaba.fastjson.JSON;import com.zyc.exception.enums.ErrorEnums;import com.zyc.vo.RestResult;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;import org.apache.shiro.web.filter.authz.AuthorizationFilter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.RequestMethod; import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter; public class JWTFilter extends AuthorizationFilter { private static Logger logger = LoggerFactory.getLogger(JWTFilter.class); /** * 判断用户是否想要登入。 * 检测header里面是否包含Authorization字段即可 */ //@Override protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) { logger.info(&quot;-----isLoginAttempt----&quot;); HttpServletRequest req = (HttpServletRequest) request; String authorization = req.getHeader(&quot;Authorization&quot;); return authorization != null; } /** * 实现用户登录 */ //@Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception { logger.info(&quot;-----executeLogin----&quot;); HttpServletRequest httpServletRequest = (HttpServletRequest) request; String authorization = httpServletRequest.getHeader(&quot;Authorization&quot;); JWTToken token = new JWTToken(authorization); // 提交给realm进行登入，如果错误他会抛出异常并被捕获 getSubject(request, response).login(token); // 如果没有抛出异常则代表登入成功，返回true return true; } /** * 该注释并非现在方法的注释，是以前版本的，不要受影响，写在这里只是提醒还有其他写法 * * 这里我们详细说明下为什么最终返回的都是true，即允许访问 * 例如我们提供一个地址 GET /article * 登入用户和游客看到的内容是不同的 * 如果在这里返回了false，请求会被直接拦截，用户看不到任何东西 * 所以我们在这里返回true，Controller中可以通过 subject.isAuthenticated() 来判断用户是否登入 * 如果有些资源只有登入用户才能访问，我们只需要在方法上面加上 @RequiresAuthentication 注解即可 * 但是这样做有一个缺点，就是不能够对GET,POST等请求进行分别过滤鉴权(因为我们重写了官方的方法)，但实际上对应用影响不大 */ @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { logger.info(&quot;-----isAccessAllowed----&quot;); if (isLoginAttempt(request, response)) { try { executeLogin(request, response); } catch (Exception e) { response401(response); } } String id = request.getParameter(&quot;id&quot;); Subject subject = getSubject(request,response); boolean flag = subject.isPermitted(id); return flag; } /** * 对跨域提供支持 */ @Override protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception { logger.info(&quot;-----preHandle----&quot;); HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; httpServletResponse.setHeader(&quot;Access-control-Allow-Origin&quot;, httpServletRequest.getHeader(&quot;Origin&quot;)); httpServletResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httpServletRequest.getMethod()); httpServletResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); httpServletResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, httpServletRequest.getHeader(&quot;Access-Control-Request-Headers&quot;)); // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态 if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) { httpServletResponse.setStatus(HttpStatus.OK.value()); return true; } return super.preHandle(request, response); } /** * onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；如果返回 false 表示该拦截器实例已经处理了，将直接返回即可。 * @param servletRequest * @param servletResponse * @return * @throws Exception */ @Override protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) { logger.info(&quot;当 isAccessAllowed 返回 false 的时候，才会执行 method onAccessDenied &quot;); try { HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse; RestResult result = new RestResult(); result.setCode(ErrorEnums.PERMISSION_DENIED.getCode()); result.setMsg(ErrorEnums.PERMISSION_DENIED.getMsg()); httpServletResponse.setContentType(&quot;application/json;charset=UTF-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.print(JSON.toJSONString(result)); out.flush(); out.close(); } catch (IOException e) { logger.error(e.getMessage()); } // 返回 false 表示已经处理，例如页面跳转啥的，表示不在走以下的拦截器了（如果还有配置的话） return false; } /** * 非法请求返回code401 */ private void response401(ServletResponse resp) { logger.info(&quot;-----response401----&quot;); try { HttpServletResponse httpServletResponse = (HttpServletResponse) resp; RestResult result = new RestResult(); result.setCode(ErrorEnums.TOKEN_MISS.getCode()); result.setMsg(ErrorEnums.TOKEN_MISS.getMsg()); httpServletResponse.setContentType(&quot;application/json;charset=UTF-8&quot;); PrintWriter out = httpServletResponse.getWriter(); out.print(JSON.toJSONString(result)); out.flush(); out.close(); } catch (IOException e) { logger.error(e.getMessage()); } }} JWTToken.java 12345678910111213141516171819202122package com.zyc.shiro; import org.apache.shiro.authc.AuthenticationToken; public class JWTToken implements AuthenticationToken { private String token; public JWTToken(String token) { this.token = token; } @Override public Object getPrincipal() { return token; } @Override public Object getCredentials() { return getPrincipal(); }} ShiroConfigurer.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.zyc; import com.zyc.shiro.*;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.authz.ModularRealmAuthorizer;import org.apache.shiro.authz.permission.PermissionResolver;import org.apache.shiro.authz.permission.RolePermissionResolver;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;import org.apache.shiro.mgt.DefaultSubjectDAO;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.realm.Realm;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn; import java.util.*; @Configurationpublic class ShiroConfigurer { private static final Logger logger = LoggerFactory.getLogger(ShiroConfigurer.class); /** * Shiro的Web过滤器Factory 命名:shiroFilter&lt;br /&gt; * * @param securityManager * @return */ @Bean(name = &quot;shiroFilter&quot;) public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) { logger.info(&quot;注入Shiro的Web过滤器--&gt;shiroFilter {}&quot;, ShiroFilterFactoryBean.class); ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // Shiro的核心安全接口,这个属性是必须的 shiroFilterFactoryBean.setSecurityManager(securityManager); // 要求登录时的链接(可根据项目的URL进行替换),非必须的属性,默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 // shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;) // 登录成功后要跳转的连接,逻辑也可以自定义，例如返回上次请求的页面 // shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;) // 用户访问未对其授权的资源时,所显示的连接 // shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/pages/403&quot;) /* 定义shiro过滤器,例如实现自定义的FormAuthenticationFilter，需要继承FormAuthenticationFilter **本例中暂不自定义实现，在下一节实现验证码的例子中体现 */ /*定义shiro过滤链 Map结构 * Map中key(xml中是指value值)的第一个'/'代表的路径是相对于HttpServletRequest.getContextPath()的值来的 * anon：它对应的过滤器里面是空的,什么都没做,这里.do和.jsp后面的*表示参数,比方说login.jsp?main这种 * authc：该过滤器下的页面必须验证后才能访问,它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter */ // 添加自己的过滤器并且取名为jwt Map filterMap = new HashMap(); filterMap.put(&quot;jwt&quot;, new JWTFilter()); shiroFilterFactoryBean.setFilters(filterMap); Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); // 配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了 // &lt;!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了 // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt; // filterChainDefinitionMap.put(&quot;/webui/**&quot;, &quot;anon&quot;) // filterChainDefinitionMap.put(&quot;/webjars/**&quot;, &quot;anon&quot;) //filterChainDefinitionMap.put(&quot;/sys/login&quot;, &quot;anon&quot;); //filterChainDefinitionMap.put(&quot;/sys/logout&quot;, &quot;anon&quot;); //filterChainDefinitionMap.put(&quot;/token/callback&quot;, &quot;anon&quot;); //filterChainDefinitionMap.put(&quot;/dist&quot;, &quot;anon&quot;); //filterChainDefinitionMap.put(&quot;/download/excel&quot;, &quot;anon&quot;); //登陆相关api不需要被过滤器拦截 filterChainDefinitionMap.put(&quot;/user/login&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;); // 所有请求通过JWT Filter filterChainDefinitionMap.put(&quot;/**&quot;, &quot;jwt&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; } @Bean public JWTFilter jwtFilter() { return new JWTFilter(); } /** * Shiro Realm 继承自AuthorizingRealm的自定义Realm,即指定Shiro验证用户登录的类为自定义的 * * @param * @return managerRealm */ @Bean public CustomRealm userRealm() { CustomRealm userRealm = new CustomRealm(); // 告诉realm,使用credentialsMatcher加密算法类来验证密文 // userRealm.setCredentialsMatcher(hashedCredentialsMatcher()) userRealm.setCachingEnabled(false); //自定义权限解析器 return userRealm; } /** * 不指定名字的话，自动创建一个方法名第一个字母小写的bean * * @return * @Bean(name = &quot;securityManager&quot;) */ @Bean public SecurityManager securityManager() { logger.info(&quot;注入Shiro的Web过滤器--&gt;securityManager {}&quot;, ShiroFilterFactoryBean.class); DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm()); DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); // 关闭自带session DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator(); defaultSessionStorageEvaluator.setSessionStorageEnabled(false); subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator); securityManager.setSubjectDAO(subjectDAO); return securityManager; } /** * 凭证匹配器 * （由于我们的密码校验交给Shiro的SimpleAuthenticationInfo进行处理了 * 所以我们需要修改下doGetAuthenticationInfo中的代码; * ） * 可以扩展凭证匹配器，实现 输入密码错误次数后锁定等功能，下一次 * * @return */ @Bean(name = &quot;credentialsMatcher&quot;) public HashedCredentialsMatcher hashedCredentialsMatcher() { HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName(&quot;SHA-512&quot;); //散列的次数，比如散列两次，相当于 md5(md5(&quot;&quot;)) hashedCredentialsMatcher.setHashIterations(2); //storedCredentialsHexEncoded默认是true，此时用的是密码加密用的是Hex编码；false时用Base64编码 hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true); return hashedCredentialsMatcher; } /** * Shiro生命周期处理器 * * @return */ @Bean public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() { return new LifecycleBeanPostProcessor(); } /** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能 * * @return */ @Bean @DependsOn({&quot;lifecycleBeanPostProcessor&quot;}) public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); advisorAutoProxyCreator.setUsePrefix(true); return advisorAutoProxyCreator; } @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager()); return authorizationAttributeSourceAdvisor; } }","link":"/2020/04/12/Spring%20Boot/03/"}],"tags":[{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Neo4j","slug":"Neo4j","link":"/tags/Neo4j/"},{"name":"Hive","slug":"Hive","link":"/tags/Hive/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"},{"name":"Jwt","slug":"Jwt","link":"/tags/Jwt/"}],"categories":[{"name":"IDEA使用","slug":"IDEA使用","link":"/categories/IDEA%E4%BD%BF%E7%94%A8/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Mybatis-Plus","slug":"Mybatis-Plus","link":"/categories/Mybatis-Plus/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}